# Generated by Grammarinator 23.7

import itertools

from math import inf
from grammarinator.runtime import *

class ConvertedGrammarGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def prog(self, parent=None):
        with RuleContext(self, UnparserRule(name='prog', parent=parent)) as current:
            self.ip(parent=current)
            self.EOF(parent=current)
            return current
    prog.min_depth = 3

    def ip(self, parent=None):
        with RuleContext(self, UnparserRule(name='ip', parent=parent)) as current:
            with AlternationContext(self, [2, 5], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.ipv4, self.ipv6][choice0](parent=current)
            return current
    ip.min_depth = 2

    def ipv4(self, parent=None):
        with RuleContext(self, UnparserRule(name='ipv4', parent=parent)) as current:
            self.octet(parent=current)
            UnlexerRule(src='.', parent=current)
            self.octet(parent=current)
            UnlexerRule(src='.', parent=current)
            self.octet(parent=current)
            UnlexerRule(src='.', parent=current)
            self.octet(parent=current)
            return current
    ipv4.min_depth = 1

    def octet(self, parent=None):
        with RuleContext(self, UnparserRule(name='octet', parent=parent)) as current:
            with AlternationContext(self, [0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='0', parent=current)
                elif choice0 == 1:
                    self.digitnozero(parent=current)
                elif choice0 == 2:
                    self.digitnozero(parent=current)
                    self.digit1(parent=current)
                elif choice0 == 3:
                    UnlexerRule(src='1', parent=current)
                    self.digit1(parent=current)
                    self.digit1(parent=current)
                elif choice0 == 4:
                    UnlexerRule(src='2', parent=current)
                    self.digit2(parent=current)
                    self.digit1(parent=current)
                elif choice0 == 5:
                    UnlexerRule(src='2', parent=current)
                    UnlexerRule(src='5', parent=current)
                    self.digit3(parent=current)
            return current
    octet.min_depth = 0

    def digit1(self, parent=None):
        with RuleContext(self, UnparserRule(name='digit1', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'][choice0], parent=current)
            return current
    digit1.min_depth = 0

    def digit2(self, parent=None):
        with RuleContext(self, UnparserRule(name='digit2', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['0', '1', '2', '3', '4'][choice0], parent=current)
            return current
    digit2.min_depth = 0

    def digit3(self, parent=None):
        with RuleContext(self, UnparserRule(name='digit3', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['0', '1', '2', '3', '4', '5'][choice0], parent=current)
            return current
    digit3.min_depth = 0

    def digitnozero(self, parent=None):
        with RuleContext(self, UnparserRule(name='digitnozero', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['1', '2', '3', '4', '5', '6', '7', '8', '9'][choice0], parent=current)
            return current
    digitnozero.min_depth = 0

    def ipv6(self, parent=None):
        with RuleContext(self, UnparserRule(name='ipv6', parent=parent)) as current:
            self.hextet(parent=current)
            UnlexerRule(src=':', parent=current)
            self.hextet(parent=current)
            UnlexerRule(src=':', parent=current)
            self.hextet(parent=current)
            UnlexerRule(src=':', parent=current)
            self.hextet(parent=current)
            UnlexerRule(src=':', parent=current)
            self.hextet(parent=current)
            UnlexerRule(src=':', parent=current)
            self.hextet(parent=current)
            UnlexerRule(src=':', parent=current)
            self.hextet(parent=current)
            UnlexerRule(src=':', parent=current)
            self.hextet(parent=current)
            return current
    ipv6.min_depth = 4

    def hextet(self, parent=None):
        with RuleContext(self, UnparserRule(name='hextet', parent=parent)) as current:
            with AlternationContext(self, [3, 3, 3, 3], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.h1, self.h2, self.h3, self.h4][choice0](parent=current)
            return current
    hextet.min_depth = 3

    def h1(self, parent=None):
        with RuleContext(self, UnparserRule(name='h1', parent=parent)) as current:
            self.hex(parent=current)
            return current
    h1.min_depth = 2

    def h2(self, parent=None):
        with RuleContext(self, UnparserRule(name='h2', parent=parent)) as current:
            self.hex(parent=current)
            self.hex(parent=current)
            return current
    h2.min_depth = 2

    def h3(self, parent=None):
        with RuleContext(self, UnparserRule(name='h3', parent=parent)) as current:
            self.hex(parent=current)
            self.hex(parent=current)
            self.hex(parent=current)
            return current
    h3.min_depth = 2

    def h4(self, parent=None):
        with RuleContext(self, UnparserRule(name='h4', parent=parent)) as current:
            self.hex(parent=current)
            self.hex(parent=current)
            self.hex(parent=current)
            self.hex(parent=current)
            return current
    h4.min_depth = 2

    def hex(self, parent=None):
        with RuleContext(self, UnparserRule(name='hex', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.digit1, self.letter][choice0](parent=current)
            return current
    hex.min_depth = 1

    def letter(self, parent=None):
        with RuleContext(self, UnparserRule(name='letter', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['a', 'b', 'c', 'd', 'e', 'f'][choice0], parent=current)
            return current
    letter.min_depth = 0

    def WS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
            return current
    WS.min_depth = 0

    _default_rule = prog

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
    }
